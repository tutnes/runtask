
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
  * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
  **/ 

package com.dynatrace.plugin;

import com.dynatrace.diagnostics.pdk.*;
import com.dynatrace.diagnostics.pdk.Violation.TriggerValue;
import com.dynatrace.plugin.utils.HelperUtils;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.codec.binary.Base64;
import org.apache.http.Header;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpHost;
import org.apache.http.HttpStatus;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.StringEntity;

import org.apache.http.impl.client.*;

import org.apache.http.conn.ssl.*;

import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import org.apache.http.message.BasicHeader;
import org.apache.http.protocol.HTTP;
import org.json.JSONObject;

public class ServiceNowAction implements Action {

	private static final Logger log = Logger.getLogger(ServiceNowAction.class.getName());
	private static String user;
	private static String password;
	private static String domain;
	private static String assignTo;
	private static String cmdbci;
	private static String incID;
	private static String dtProfile;
	
	private final static String PARAM_USER = "user";
	private final static String PARAM_PASSWORD = "password";
	private final static String PARAM_USE_PROXY="useProxy"; 
	private final static String PARAM_PROXY_HOST="proxyHost"; 
	private final static String PARAM_PROXY_PORT="proxyPort"; 
	private final static String PARAM_PROXY_AUTHENTICATION_REQD="proxyAuthenticationRequired"; 
	private final static String PARAM_PROXY_USERNAME="proxyUserName"; 
	private final static String PARAM_PROXY_PASSWORD="proxyPassword"; 
	private final static String PARAM_DOMAIN = "domain";
	private final static String PARAM_SYSTEM_PROFILE = "system_profile";
	private final static String PARAM_TASK = "task";
	private final static String PARAM_IGNORE_CERT = "ignore_certificate";
	
	private String domainAppend;
	private String url;
	private String authString;
	private boolean useProxy;
	private boolean proxyAuthenticationRequired;
	private String proxyHost;
	private int proxyPort;
	private String proxyUserName;
	private String proxyPassword;
	private String system_profile;
	private String task;
	private boolean ignoreCert;
	
	/**
	 * Initializes the Action Plugin. This method is always 
	 * called before <tt>execute</tt>.
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then <tt>execute</tt> will not be called.
	 *
	 * @param env the configured <tt>ActionEnvironment</tt> for this Plugin;
	 *            <b>does not contain any incidents</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 * @throws Exception
	 */
	@Override
	public Status setup(ActionEnvironment env) throws Exception {
		//retrieve the values passed to this action.
		user = env.getConfigString(PARAM_USER);
		password = env.getConfigPassword(PARAM_PASSWORD);
		domain = env.getConfigUrl(PARAM_DOMAIN).toString();
		system_profile = env.getConfigString(PARAM_SYSTEM_PROFILE);
		task = env.getConfigString(PARAM_TASK);
		domainAppend = "/api/v2/profiles/" + system_profile + "/tasks/" + task + "/status";
		ignoreCert = env.getConfigBoolean(PARAM_IGNORE_CERT).booleanValue();
		useProxy = env.getConfigBoolean(PARAM_USE_PROXY).booleanValue();
		if (useProxy) {
			proxyHost = env.getConfigString(PARAM_PROXY_HOST);
			proxyPort = env.getConfigLong(PARAM_PROXY_PORT).intValue();
			
			proxyAuthenticationRequired = env.getConfigBoolean(PARAM_PROXY_AUTHENTICATION_REQD).booleanValue();
			if (proxyAuthenticationRequired) {
				proxyUserName = env.getConfigString(PARAM_PROXY_USERNAME);
				proxyPassword = env.getConfigPassword(PARAM_PROXY_PASSWORD);
			}
		}

		
		String error="";
		if (user == null || user == "") {
			error = "User not defined. \n";
		}




		
		if (password == null || password == "") {
			error = error + "Password not defined. \n";
		}
				
		if ( domain == null || domain == "") {
			error = error + "Domain not defined. \n";
		}
		
		if (useProxy && (proxyHost == null || proxyHost.isEmpty())) {
			error = error + " Proxy Host is required when using proxy";
		}
		
		if (useProxy && proxyPort == 0) {
			error = error + " Proxy Port is required when using proxy";
		}
		
		if (proxyAuthenticationRequired && (proxyUserName == null || proxyUserName.isEmpty())) {
			error = error + " Proxy user name is required when using proxy authentication";
		}
		if (proxyAuthenticationRequired && (proxyPassword == null || proxyPassword.isEmpty())) {
			error = error + " Proxy password is required when using proxy authentication";
		}

		if (domainAppend == null || domainAppend.isEmpty()) {
			error = error + " Domain append value cannot be empty";
		}
		
		if ( error != "") {
			return new Status(Status.StatusCode.ErrorInternalConfigurationProblem, error);
		}
		
		
		authString = buildAuthString(user, password);
 		url = domain + domainAppend;

 		log.log(Level.FINER, "Setup is successful");
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Action Plugin to process incidents.
	 *
	 * <p>
	 * This method is called at the scheduled intervals, but only if incidents
	 * occurred in the meantime. If the Plugin execution takes longer than the
	 * schedule interval, subsequent calls to
	 * {@link #execute(ActionEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>ActionEnvironment</tt> object that contains the Plugin
	 *            configuration and incidents
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */	@Override
	public Status execute(ActionEnvironment env) throws Exception {

		 HttpClientBuilder builder = HttpClientBuilder.create();
		 if (useProxy) {
			 HttpHost proxy = new HttpHost(proxyHost, proxyPort);
			if (proxyAuthenticationRequired) {
				 log.log(Level.FINER, "P-UserName=" + proxyUserName);
				 CredentialsProvider credsProvider = new BasicCredentialsProvider();
				 credsProvider.setCredentials(
						 new AuthScope(proxyHost, proxyPort),
						 new UsernamePasswordCredentials(proxyUserName, proxyPassword));
				 builder = builder.setDefaultCredentialsProvider(credsProvider)
						 .setProxyAuthenticationStrategy(new ProxyAuthenticationStrategy());
			 }
			 builder.setProxy(proxy);
		 }


		 // SSL Hack
		CloseableHttpClient client;


		if (ignoreCert) {
			SSLContextBuilder sslbuilder = new SSLContextBuilder();
			sslbuilder.loadTrustMaterial(null, new TrustStrategy(){
				public boolean isTrusted(X509Certificate[] chain, String authType)
						throws CertificateException {
					return true;
				}
			});
			sslbuilder.loadTrustMaterial(null, new TrustSelfSignedStrategy());

			SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
					sslbuilder.build(),new NoopHostnameVerifier());
			client = HttpClients
					.custom()
					.setSSLSocketFactory(sslsf).build();
		//			.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE);



		}
		else {

			client = builder.build();
		}
		 Header header 	= new BasicHeader(HttpHeaders.CONTENT_TYPE, "application/json");
		 List<Header> headers = new ArrayList<Header>();
		 headers.add(header);

		 HttpPut post = new HttpPut(url);
		 post.setHeader(header);

		 post.addHeader("AUTHORIZATION", "Basic " + authString);
		 String postBody = buildPostBody(env);

		 try {
			 StringEntity se = new StringEntity(postBody);
			  post.setEntity(se);
			 CloseableHttpResponse response = client.execute(post);
			 int responseCode = response.getStatusLine().getStatusCode();

			 if (responseCode != HttpStatus.SC_ACCEPTED) {
				 log.log(Level.SEVERE, "HTTP Response Code =" + responseCode);
				 return new Status(Status.StatusCode.ErrorTargetServiceExecutionFailed, "HTTP Response Code =" + responseCode);
			 }
			 BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));

			 StringBuffer result = new StringBuffer();
			 String line = "";
			 while ((line = rd.readLine()) != null) {
				 result.append(line);
			 }

			 log.log(Level.FINER, result.toString());

			 return new Status(Status.StatusCode.Success, (String) "Task PUT OK");
		 }
		 catch (MalformedURLException me) {
			 log.log(Level.SEVERE, HelperUtils.getStackTraceAsString(me));
			 return new Status(Status.StatusCode.ErrorTargetServiceExecutionFailed, HelperUtils.getExceptionAsString(me));
		 }
		 catch (Exception e) {
			 log.log(Level.SEVERE, HelperUtils.getStackTraceAsString(e));
			 return new Status(Status.StatusCode.ErrorTargetServiceExecutionFailed, HelperUtils.getExceptionAsString(e));
		 }
		 finally {
			 if (client != null ) {
				 client.close();
			 }
		 }
	}
	/**
	 * Shuts the Plugin down and frees resources. This method is called either way
	 * if the Action setup/execution has failed or was successful.
	 *
	 * @see Action#setup(ActionEnvironment)
	 */
	@Override
	public void teardown(ActionEnvironment env) throws Exception {
	}
	
	private String buildPostBody(ActionEnvironment env) {
		Map<String, String> jObj = new LinkedHashMap<String, String>();


		Collection<Incident> incidents = env.getIncidents();
		if(incidents == null) {
			log.severe("No incidents found.");
			return null;
		}

		double triggeredValue = 0;
		double thresholdValue = 0;
		String split = "";
		String incidentRule = null;



		for (Incident i : incidents) { 
			incID = i.getKey().getUUID();
			dtProfile = i.getKey().getSystemProfile();


			
			Collection<Violation> violations = i.getViolations(); 
			for (Violation v : violations) { 
				Collection<TriggerValue> triggerValues = v.getTriggerValues();

				//log.log(Level.SEVERE, "Source="+source);
				for (TriggerValue t : triggerValues) { 
					triggeredValue = t.getValue().getValue(); 
				} 
				List<String> splitting = v.getViolatedMeasure().getSplittings(); 
				thresholdValue = v.getViolatedThreshold().getValue().getValue(); 

				if ( splitting != null) { 
					for (String s: splitting) { 
						split += s; 
					} 
				} 
			} 
			incidentRule = i.getIncidentRule().getName(); 

		}


		String summary = "Incident:" + incidentRule;
		log.log(Level.FINER, "Summary=" + summary);

		jObj.put("status", "RUNNING");
				
		log.log(Level.FINER, "Body=\n" + new JSONObject(jObj).toString());
 		return new JSONObject(jObj).toString();
	}
	private String buildAuthString(String user, String password) {
		String authString = user + ":" + password;
		byte[] authEncBytes = Base64.encodeBase64(authString.getBytes());
		return new String(authEncBytes);		
	}


}
